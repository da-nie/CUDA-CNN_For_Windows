#ifndef C_IMAGE_H
#define C_IMAGE_H

//****************************************************************************************************
//Класс обучающих изображений для нейросети
//****************************************************************************************************

//****************************************************************************************************
//подключаемые библиотеки
//****************************************************************************************************
#include <vector>
#include <string>
#include "cmatrix.h"
#include "tga.h"

//****************************************************************************************************
//макроопределения
//****************************************************************************************************

//****************************************************************************************************
//константы
//****************************************************************************************************

//****************************************************************************************************
//предварительные объявления
//****************************************************************************************************

//****************************************************************************************************
//Класс обучающих изображений для нейросети
//****************************************************************************************************
template<class type_t>
class CImage
{
 public:
  //-переменные-----------------------------------------------------------------------------------------
  //-перечисления---------------------------------------------------------------------------------------
  //-структуры------------------------------------------------------------------------------------------
  //-константы------------------------------------------------------------------------------------------
  static const size_t COLOR_CHANNEL=3;//количество цветовых каналов
 private:
  //-переменные-----------------------------------------------------------------------------------------
 public:
  //-конструктор----------------------------------------------------------------------------------------
  CImage(void);
  //-деструктор-----------------------------------------------------------------------------------------
  ~CImage();
 public:
  //-открытые функции-----------------------------------------------------------------------------------
  bool Load(CMatrix<type_t> &cMatrix_Image,const std::string &file_name,size_t image_width,size_t image_height);//загрузить изображение
  bool Normalize(CMatrix<type_t> &cMatrix_Image);//нормализовать изображение
  bool ToSingleLayer(CMatrix<type_t> &cMatrix_Image);//привести к одному слою
 private:
  //-закрытые функции-----------------------------------------------------------------------------------
};

//****************************************************************************************************
//глобальные переменные
//****************************************************************************************************

//****************************************************************************************************
//константы
//****************************************************************************************************

//****************************************************************************************************
//макроопределения
//****************************************************************************************************

//****************************************************************************************************
//конструктор и деструктор
//****************************************************************************************************

//----------------------------------------------------------------------------------------------------
//конструктор
//----------------------------------------------------------------------------------------------------
template<class type_t>
CImage<type_t>::CImage(void)
{
}
//----------------------------------------------------------------------------------------------------
//деструктор
//----------------------------------------------------------------------------------------------------
template<class type_t>
CImage<type_t>::~CImage()
{
}

//****************************************************************************************************
//закрытые функции
//****************************************************************************************************

//****************************************************************************************************
//открытые функции
//****************************************************************************************************

//----------------------------------------------------------------------------------------------------
//загрузить изображение
//----------------------------------------------------------------------------------------------------
template<class type_t>
bool CImage<type_t>::Load(CMatrix<type_t> &cMatrix_Image,const std::string &file_name,size_t image_width,size_t image_height)
{
 int32_t width;
 int32_t height;
 uint32_t *img_ptr=reinterpret_cast<uint32_t*>(LoadTGAFromFile(file_name.c_str(),width,height));//загрузить tga-файл
 if (img_ptr==NULL) return(false);
 if (width!=image_width || height!=image_height)
 {
  delete[](img_ptr);
  return(false);
 }
 CMatrix<type_t> cMatrix(COLOR_CHANNEL,width*height);
 cMatrix_Image=cMatrix;
 //преобразуем изображение
 size_t pos=0;
 uint32_t *i_ptr=img_ptr;
 for(int32_t y=0;y<height;y++)
 {
  for(int32_t x=0;x<width;x++,i_ptr++,pos++)
  {
   uint32_t color=*i_ptr;
   uint8_t r=(color>>0)&0xff;
   uint8_t g=(color>>8)&0xff;
   uint8_t b=(color>>16)&0xff;

   float nr=r;
   float ng=g;
   float nb=b;

   nr/=255.0;
   ng/=255.0;
   nb/=255.0;

   if (COLOR_CHANNEL>=1) cMatrix_Image.SetElement(0,pos,nr);
   if (COLOR_CHANNEL>=2) cMatrix_Image.SetElement(1,pos,ng);
   if (COLOR_CHANNEL>=3) cMatrix_Image.SetElement(2,pos,nb);
  }
 }
 delete[](img_ptr);
 return(true);
}
//----------------------------------------------------------------------------------------------------
//нормализовать изображение
//----------------------------------------------------------------------------------------------------
template<class type_t>
bool CImage<type_t>::Normalize(CMatrix<type_t> &cMatrix_Image)
{
 static const type_t EPS=static_cast<type_t>(0.00001);

 size_t size=cMatrix_Image.GetSizeX()*cMatrix_Image.GetSizeY();
 //type_t size_channel=cMatrix_Image.GetSizeX();
 type_t min=1;
 type_t max=0;
 type_t *m_ptr=cMatrix_Image.GetColumnPtr(0);
 for(size_t n=0;n<size;n++,m_ptr++)
 {
  type_t v=*m_ptr;
  if (v<min) min=v;
  if (v>max) max=v;
 }
 type_t delta=max-min;
 if (fabs(delta)<EPS) delta=1;

 m_ptr=cMatrix_Image.GetColumnPtr(0);
 for(size_t n=0;n<size;n++,m_ptr++)
 {
  type_t v=*m_ptr;
  v-=min;
  v/=delta;
  //v/=size_channel;
  *m_ptr=v;
 }
 return(true);
}
//----------------------------------------------------------------------------------------------------
//привести к одному слою
//----------------------------------------------------------------------------------------------------
template<class type_t>
bool CImage<type_t>::ToSingleLayer(CMatrix<type_t> &cMatrix_Image)
{
 //усредняем слои
 CMatrix<type_t> cMatrix_Output(1,cMatrix_Image.GetSizeX());
 size_t width=cMatrix_Image.GetSizeX();
 size_t height=cMatrix_Image.GetSizeY();
 for(size_t x=0;x<width;x++)
 {
  type_t output=0;
  for(size_t y=0;y<height;y++)
  {
   output+=cMatrix_Image.GetElement(y,x);
  }
  output/=static_cast<type_t>(height);
  cMatrix_Output.SetElement(0,x,output);
 }
 cMatrix_Image.Move(cMatrix_Output);
 return(true);
}
#endif


